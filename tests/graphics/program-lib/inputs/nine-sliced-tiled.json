{
  "fog": "none",
  "gamma": 0,
  "toneMap": -1,
  "blendMapsWithColors": true,
  "ambientTint": false,
  "diffuseTint": 3,
  "specularTint": 0,
  "metalnessTint": 0,
  "glossTint": 1,
  "emissiveTint": 3,
  "opacityTint": 1,
  "alphaTest": false,
  "alphaToCoverage": false,
  "needsNormalFloat": true,
  "sphereMap": false,
  "cubeMap": false,
  "dpAtlas": false,
  "ambientSH": false,
  "useSpecular": false,
  "rgbmAmbient": false,
  "rgbmReflection": false,
  "hdrAmbient": false,
  "hdrReflection": false,
  "fixSeams": false,
  "prefilteredCubemap": false,
  "emissiveFormat": 0,
  "lightMapFormat": null,
  "useRgbm": 0,
  "specularAntialias": false,
  "conserveEnergy": true,
  "occludeSpecular": 1,
  "occludeSpecularFloat": false,
  "occludeDirect": false,
  "shadingModel": 1,
  "fresnelModel": 0,
  "packedNormal": false,
  "forceFragmentPrecision": null,
  "fastTbn": false,
  "cubeMapProjection": 0,
  "chunks": {
      "basePS": "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n    return x*x;\n}\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform vec4 innerOffset;\nuniform vec2 outerScale;\nuniform vec4 atlasRect;\nvec2 nineSlicedUv;",
      "startPS": "\nvoid main(void) {\n    dDiffuseLight = vec3(0);\n    dSpecularLight = vec3(0);\n    dReflection = vec4(0);\n    dSpecularity = vec3(0);\nvec2 tileMask = step(vMask, vec2(0.99999));\nvec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\nclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\nnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);",
      "emissivePS": "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n    vec3 emission = vec3(1.0);\n    #ifdef MAPFLOAT\n        emission *= material_emissiveIntensity;\n    #endif\n    #ifdef MAPCOLOR\n        emission *= material_emissive;\n    #endif\n    #ifdef MAPTEXTURE\n        emission *= $texture2DSAMPLE(texture_emissiveMap, nineSlicedUv, -1000.0).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        emission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n    return emission;\n}\n",
      "opacityPS": "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n    dAlpha = 1.0;\n    #ifdef MAPFLOAT\n        dAlpha *= material_opacity;\n    #endif\n    #ifdef MAPTEXTURE\n        dAlpha *= texture2D(texture_opacityMap, nineSlicedUv, -1000.0).$CH;\n    #endif\n    #ifdef MAPVERTEX\n        dAlpha *= saturate(vVertexColor.$VC);\n    #endif\n}\n",
      "transformVS": "#define NINESLICED\n#ifdef PIXELSNAP\n    uniform vec4 uScreenSize;\n#endif\n#ifdef NINESLICED\n    #ifndef NINESLICE\n    #define NINESLICE\n    uniform vec4 innerOffset;\n    uniform vec2 outerScale;\n    uniform vec4 atlasRect;\n    varying vec2 vTiledUv;\n    #endif\n#endif\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n        return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n        return matrix_model * (getBoneMatrix(vertex_boneIndices.x) * vertex_boneWeights.x +\n               getBoneMatrix(vertex_boneIndices.y) * vertex_boneWeights.y +\n               getBoneMatrix(vertex_boneIndices.z) * vertex_boneWeights.z +\n               getBoneMatrix(vertex_boneIndices.w) * vertex_boneWeights.w);\n    #elif defined(INSTANCING)\n        return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n        return matrix_model;\n    #endif\n}\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n    #ifdef NINESLICED\n        // outer and inner vertices are at the same position, scale both\n        localPos.xz *= outerScale;\n        // offset inner vertices inside\n        // (original vertices must be in [-1;1] range)\n        vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n        vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n        localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n        vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n        localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n        localPos = localPos.xzy;\n    #endif\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n        posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n        screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n        #ifdef SCREENSPACE\n            screenPos = posW;\n        #else\n            screenPos = matrix_viewProjection * posW;\n        #endif\n        #ifdef PIXELSNAP\n            // snap vertex to a pixel boundary\n            screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n            screenPos.xy *= uScreenSize.xy;\n            screenPos.xy = floor(screenPos.xy);\n            screenPos.xy *= uScreenSize.zw;\n            screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n        #endif\n    #endif\n    return screenPos;\n}\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n",
      "uv0VS": "#ifndef NINESLICE\n#define NINESLICE\nuniform vec4 innerOffset;\nuniform vec2 outerScale;\nuniform vec4 atlasRect;\nvarying vec2 vTiledUv;\n#endif\nvarying vec2 vMask;\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n    vMask = vertex_texCoord0.xy;\n    return uv;\n}\n"
  },
  "customFragmentShader": null,
  "refraction": false,
  "useMetalness": false,
  "blendType": 4,
  "forceUv1": false,
  "useTexCubeLod": false,
  "msdf": false,
  "twoSidedLighting": false,
  "pixelSnap": false,
  "pass": 0,
  "noShadow": false,
  "screenSpace": false,
  "skin": false,
  "useInstancing": false,
  "emissiveMap": true,
  "emissiveMapTransform": 0,
  "emissiveMapChannel": "rgb",
  "emissiveMapUv": 0,
  "opacityMap": true,
  "opacityMapTransform": 0,
  "opacityMapChannel": "a",
  "opacityMapUv": 0,
  "lights": [],
  "aoMapUv": 0
}
